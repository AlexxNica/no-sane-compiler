<!doctype html>
<html>
        <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

                <title>reveal.js</title>

                <link rel="stylesheet" href="css/reveal.css">
                <link rel="stylesheet" href="css/theme/black.css">

                <!-- Theme used for syntax highlighting of code -->
                <link rel="stylesheet" href="lib/css/zenburn.css">

                <!-- Printing and PDF exports -->
                <script>
                        var link = document.createElement( 'link' );
                        link.rel = 'stylesheet';
                        link.type = 'text/css';
                        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
                        document.getElementsByTagName( 'head' )[0].appendChild( link );
                </script>
        </head>
        <body>
                <div class="reveal">
                        <div class="slides">

<section>
  <section>
    <h1>No Sane Compiler Would Optimize Atomics</h1>
    <p><a href="https://twitter.com/jfbastien">@jfbastien</a></p>
  </section>
  <section>
    <code class="c++">false</code>
    <aside class="notes">
      <p>Compilers do optimize atomics, memory accesses around atomics, and utilize architecture-specific knowledge. My hobby is to encourage compilers to do more of this, programmers to rely on it, and hardware vendors to give us new atomic toys to optimize with. Oh, and standardize yet more close-to-the-metal concurrency and parallelism tools.</p>
      <p>But, you say, surely volatile always means volatile, there’s nothing wrong with my benign races, nothing could even go wrong with non-temporal accesses, and who needs 6 memory orderings anyways‽ I’m glad you asked, let me tell you about my hobby…</p>
    </aside>
  </section>
</section>

<section>
  <section>
    <h1><em>as-if</em></h1>
    <p class="fragment"><strong>more atomic</strong>: don’t violate forward progress</p>
    <p class="fragment"><strong>less atomic</strong>: don’t add non-benign race which weren’t already present</p>
  </section>
  <section>
    <p>Put another way</p>
    <p>correct programs must work under all executions an implementation is allowed to create</p>
    <aside class="notes">
      <p>Keep in mind: compilers optimize code that compiler developers see and think are worth optimizing. We’re not trying to trip you!</p>
    </aside>
  </section>
</section>

<section>
  <section><h1>A simple example</h1></section>
  <section><pre><code class="c++" data-noescape>
void inc(std::atomic&lt;int&gt; *y) {
  *y += 1;
}
std::atomic&lt;int&gt; x;
void two() {
  inc(&x);
  inc(&x);
}
  </code></pre></section>
  <section><pre><code class="c++" data-noescape>
std::atomic&lt;int&gt; x;
void two() {
  x += 2;
}
  </code></pre>
    <aside class="notes"><p>Adds atomicity but cannot hinder forward progress: correct.</p></aside>
  </section>
  <section><h1>Similar example</h1></section>
  <section><pre><code class="c++" data-noescape>
std::atomic&lt;int&gt; x;
void inc(int val) {
  x += 1;
  x += val;
}
  </code></pre></section>
  <section><pre><code class="x86asm" data-noescape>
_Z3inci:
  lock incl x(%rip)
  lock addl %edi, x(%rip)
  </code></pre></section>
  <section><h1>Opportunities through inlining</h1></section>
  <section><pre><code class="c++" data-noescape>
template&lt;typename T&gt;
bool silly(std::atomic&lt;T&gt; *x, T expected, T desired) {
  x-&gt;compare_exchange_strong(expected, desired); // Inlined.
  return expected == desired;
}
  </code></pre></section>
  <section><pre><code class="c++" data-noescape>
template&lt;typename T&gt;
bool silly(std::atomic&lt;T&gt; *x, T expected, T desired) {
  return x-&gt;compare_exchange_strong(expected, desired);
}
  </code></pre></section>
  <section>
    <h1>A tricky one</h1>
    <p>Works for any memory order but <code class="c++">release</code> and <code class="c++">acq_rel</code></p>
  </section>
  <section><pre><code class="c++" data-noescape>
template&lt;typename T&gt;
bool optme(std::atomic&lt;T&gt; *x, T desired) {
  T expected = desired;
  return x-&gt;compare_exchange_strong(expected, desired
    std::memory_order_seq_cst, std::memory_order_relaxed);
}
  </code></pre></section>
  <section><pre><code class="c++" data-noescape>
template&lt;typename T&gt;
bool optme(std::atomic&lt;T&gt; *x, T desired) {
  return x-&gt;load(std::memory_order_seq_cst) == desired; // †
}
  </code></pre>
    <p class="fragment"><small>† compiler: mark transformed load as <em>release sequence</em><sup>‡</sup></small></p>
    <p class="fragment"><small>‡ as defined in section 1.10 of the C++ standard</small></p>
  </section>
</section>


                        </div>
                </div>

                <script src="lib/js/head.min.js"></script>
                <script src="js/reveal.js"></script>

                <script>
                        // More info https://github.com/hakimel/reveal.js#configuration
                        Reveal.initialize({

                                controls: true, // Display controls in the bottom right corner
                                progress: true, // Display a presentation progress bar
                                history: true, // Push each slide change to the browser history
                                keyboard: true, // Enable keyboard shortcuts for navigation
                                overview: true, // Enable the slide overview mode
                                center: true, // Vertical centering of slides
                                touch: true,
                                loop: false,
                                rtl: false,
                                shuffle: false,
                                fragments: true, // Turns fragments on and off globally
                                help: true, // Flags if we should show a help overlay when the questionmark key is pressed
                                showNotes: false, // Flags if speaker notes should be visible to all viewers
                                autoSlide: 0,
                                autoSlideStoppable: true, // Stop auto-sliding after user input
                                autoSlideMethod: Reveal.navigateNext,
                                mouseWheel: false,
                                hideAddressBar: true,
                                previewLinks: false, // Opens links in an iframe preview overlay
                                transition: 'default', // none/fade/slide/convex/concave/zoom
                                transitionSpeed: 'default', // default/fast/slow
                                backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom
                                viewDistance: 3, // Number of slides away from the current that are visible
                                parallaxBackgroundImage: 'bg.jpg',
                                parallaxBackgroundSize: '2559px 1510px', // CSS syntax, e.g. "2100px 900px"
                                // Number of pixels to move the parallax background per slide
                                // - Calculated automatically unless specified
                                // - Set to 0 to disable movement along an axis
                                parallaxBackgroundHorizontal: null,
                                parallaxBackgroundVertical: null,

                                // More info https://github.com/hakimel/reveal.js#dependencies
                                dependencies: [
                                        { src: 'plugin/markdown/marked.js' },
                                        { src: 'plugin/markdown/markdown.js' },
                                        { src: 'plugin/notes/notes.js', async: true },
                                        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                                ]
                        });
                </script>
        </body>
</html>
