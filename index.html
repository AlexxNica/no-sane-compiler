<!doctype html>
<html>
        <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

                <title>No sane compiler would optimize atomics</title>

                <link rel="stylesheet" href="css/reveal.css">
                <link rel="stylesheet" href="css/theme/black.css">

                <!-- Theme used for syntax highlighting of code -->
                <link rel="stylesheet" href="lib/css/zenburn.css">

                <!-- Printing and PDF exports -->
                <script>
                        var link = document.createElement( 'link' );
                        link.rel = 'stylesheet';
                        link.type = 'text/css';
                        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
                        document.getElementsByTagName( 'head' )[0].appendChild( link );
                </script>
        </head>
        <body>
                <div class="reveal">
                        <div class="slides">

<section>
  <section>
    <h1>No Sane Compiler Would Optimize Atomics</h1>
    <p><a href="https://twitter.com/jfbastien">@jfbastien</a></p>
  </section>
  <section>
    <code class="c++">false</code>
    <aside class="notes">
      <p>Compilers do optimize atomics, memory accesses around atomics, and utilize architecture-specific knowledge. My hobby is to encourage compilers to do more of this, programmers to rely on it, and hardware vendors to give us new atomic toys to optimize with. Oh, and standardize yet more close-to-the-metal concurrency and parallelism tools.</p>
      <p>But, you say, surely volatile always means volatile, there’s nothing wrong with my benign races, nothing could even go wrong with non-temporal accesses, and who needs 6 memory orderings anyways‽ I’m glad you asked, let me tell you about my hobby…</p>
    </aside>
  </section>
</section>

<section>
  <section>
    <h1><em>as-if</em></h1>
    <p class="fragment"><strong>more atomic</strong>: don’t violate forward progress</p>
    <p class="fragment"><strong>less atomic</strong>: don’t add non-benign race which weren’t already present</p>
  </section>
  <section>
    <p><h2>Put another way</h2></p>
    <p>correct programs must work under all executions an implementation is allowed to create</p>
    <aside class="notes">
      <p>Keep in mind: compilers optimize code that compiler developers see and think are worth optimizing. We’re not trying to trip you!</p>
    </aside>
  </section>
</section>

<section>
  <section><h2>Simple example</h2>
  <pre class="fragment"><code class="c++" data-noescape>
void inc(std::atomic&lt;int&gt; *y) {
  *y += 1;
}
std::atomic&lt;int&gt; x;
void two() {
  inc(&x);
  inc(&x);
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x;
void two() {
  x += 2;
}
  </code></pre>
    <aside class="notes"><p>Adds atomicity but cannot hinder forward progress: correct.</p></aside>
  </section>
  <section><h2>Similar example</h2>
  <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x;
void inc(int val) {
  x += 1;
  x += val;
}
  </code></pre>
  <pre class="fragment"><code class="x86asm" data-noescape>
_Z3inci:
  lock incl x(%rip)
  lock addl %edi, x(%rip)
  </code></pre>
  <aside class="notes"><p>Not going to win a Turing award with this: `inc r/m` versus `add r/m, r`; both with lock prefix; inc doesn't set carry (sometimes partial flag stall); both 3 bytes; one less register; check out Agner for μops / latency, lock prefix makes this moot. Maybe the compiler would know better after all?</p></aside>
  </section>
  <section><h2>Opportunities through inlining</h2>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool silly(std::atomic&lt;T&gt; *x, T expected, T desired) {
  x-&gt;compare_exchange_strong(expected, desired); // Inlined.
  return expected == desired;
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool silly(std::atomic&lt;T&gt; *x, T expected, T desired) {
  return x-&gt;compare_exchange_strong(expected, desired);
}
  </code></pre>
  <aside class="notes"><p>Generic code ends up with interesting cases such as these. bool is usually a flag… but returning it depends on ABI!</p></aside>
  </section>
  <section>
    <h2>A tricky one</h2>
    <p class="fragment">Works for any memory order but <code class="c++">release</code> and <code class="c++">acq_rel</code></p>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool optme(std::atomic&lt;T&gt; *x, T desired) {
  T expected = desired;
  return x-&gt;compare_exchange_strong(expected, desired
    std::memory_order_seq_cst, std::memory_order_relaxed);
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool optme(std::atomic&lt;T&gt; *x, T desired) {
  return x-&gt;load(std::memory_order_seq_cst) == desired; // †
}
  </code></pre>
    <p class="fragment"><small>† compiler: mark transformed load as <em>release sequence</em> <sup>‡</sup></small></p>
    <p class="fragment"><small>‡ as defined in section 1.10 of the C++ standard</small></p>
  </section>
  <section>
    <h2>Stronger, faster</h2>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
T optmetoo(std::atomic&lt;T&gt; *x, T y) {
  T z = x-&gt;load();
  x-&gt;store(y);
  return z;
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
T optmetoo(std::atomic&lt;T&gt; *x, T y) {
  return x-&gt;exchange(y);
}
  </code></pre>
    <h2 class="fragment">better?</h2>
    <aside class="notes"><p>May not always pay off: architectures with weaker memory models may benefit from having write-after-read operations to the same location instead of having an atomic exchange.</p></aside>
  </section>
  <section>
    <h2>Moar!</h2>
    <p class="fragment">Inlining and constant propagation</p>
    <p class="fragment"><code class="c++">atomic&lt;T&gt;::fetch_and(~(T)0)</code> → <code class="c++">atomic&lt;T&gt;::load()</code></p>
    <p class="fragment">Same for <code class="c++">fetch_or(0)</code> and <code class="c++">fetch_xor(0)</code></p>
    <p class="fragment"><code class="c++">atomic&lt;T&gt;::fetch_and(0)</code> → <code class="c++">atomic&lt;T&gt;::store(0)</code></p>
  </section>
  <section>
    <h2>Takeaway</h2>
    <p class="fragment">If simple things are hard…</p>
    <p class="fragment">…is your inline assembly correct?</p>
    <p class="fragment">…will it remain correct?</p>
    <p class="fragment">Do you trust your compiler?</p>
    <aside class="notes"><p>Sorry to say, you're already trusting your compiler (or deluding yourself).</p></aside>
  </section>
  <section>
    <p>What if the compiler emits suboptimal code?</p>
    <h2 class="fragment">File a bug!</h2>
  </section>
</section>

<section>
  <h1>Sane Compilers Should Optimize Atomics</h1>
  <p>and you should use atomics</p>
  <p>Details &amp; references: <a href="https://github.com/jfbastien/no-sane-compiler">github.com/jfbastien/no-sane-compiler</a></p>
  <p><a href="https://twitter.com/jfbastien">@jfbastien</a></p>
</section>

                        </div>
                </div>

                <script src="lib/js/head.min.js"></script>
                <script src="js/reveal.js"></script>

                <script>
                        // More info https://github.com/hakimel/reveal.js#configuration
                        Reveal.initialize({

                                controls: true, // Display controls in the bottom right corner
                                progress: true, // Display a presentation progress bar
                                history: true, // Push each slide change to the browser history
                                keyboard: true, // Enable keyboard shortcuts for navigation
                                overview: true, // Enable the slide overview mode
                                center: true, // Vertical centering of slides
                                touch: true,
                                loop: false,
                                rtl: false,
                                shuffle: false,
                                fragments: true, // Turns fragments on and off globally
                                help: true, // Flags if we should show a help overlay when the questionmark key is pressed
                                showNotes: false, // Flags if speaker notes should be visible to all viewers
                                autoSlide: 0,
                                autoSlideStoppable: true, // Stop auto-sliding after user input
                                autoSlideMethod: Reveal.navigateNext,
                                mouseWheel: false,
                                hideAddressBar: true,
                                previewLinks: false, // Opens links in an iframe preview overlay
                                transition: 'default', // none/fade/slide/convex/concave/zoom
                                transitionSpeed: 'default', // default/fast/slow
                                backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom
                                viewDistance: 3, // Number of slides away from the current that are visible
                                parallaxBackgroundImage: 'bg.jpg',
                                parallaxBackgroundSize: '2559px 1510px', // CSS syntax, e.g. "2100px 900px"
                                // Number of pixels to move the parallax background per slide
                                // - Calculated automatically unless specified
                                // - Set to 0 to disable movement along an axis
                                parallaxBackgroundHorizontal: null,
                                parallaxBackgroundVertical: null,

                                // More info https://github.com/hakimel/reveal.js#dependencies
                                dependencies: [
                                        { src: 'plugin/markdown/marked.js' },
                                        { src: 'plugin/markdown/markdown.js' },
                                        { src: 'plugin/notes/notes.js', async: true },
                                        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                                ]
                        });
                </script>
        </body>
</html>
