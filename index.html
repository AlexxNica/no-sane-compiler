<!doctype html>
<html>
        <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

                <title>No sane compiler would optimize atomics</title>

                <link rel="stylesheet" href="css/reveal.css">
                <link rel="stylesheet" href="css/theme/league.css">

                <!-- Theme used for syntax highlighting of code -->
                <link rel="stylesheet" href="lib/css/zenburn.css">

                <!-- Printing and PDF exports -->
                <script>
                        var link = document.createElement( 'link' );
                        link.rel = 'stylesheet';
                        link.type = 'text/css';
                        link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
                        document.getElementsByTagName( 'head' )[0].appendChild( link );
                </script>
        </head>
        <body>
                <div class="reveal">
                        <div class="slides">

<section>
  <section>
    <h1>No Sane Compiler Would Optimize Atomics</h1>
    <p>JF Bastien &lt;<a href="https://twitter.com/jfbastien">@jfbastien</a>&gt;</p>
    <p>Compiler engineer on Chrome</p>
  </section>
  <section>
    <strong><code class="c++" style="font-size: 400%">false</code></strong>
    <aside class="notes">
      <p>Compilers do optimize atomics, memory accesses around atomics, and utilize architecture-specific knowledge. My hobby is to encourage compilers to do more of this, programmers to rely on it, and hardware vendors to give us new atomic toys to optimize with. Oh, and standardize yet more close-to-the-metal concurrency and parallelism tools.</p>
      <p>But, you say, surely volatile always means volatile, there’s nothing wrong with my benign races, nothing could even go wrong with non-temporal accesses, and who needs 6 memory orderings anyways‽ I’m glad you asked, let me tell you about my hobby…</p>
    </aside>
  </section>
  <section>
    <h1>Disclaimer</h1>
    <aside class="notes">Peek under the hood. Prefer higher-level primitives (parallelism TS, mutex, etc).</aside>
  </section>
  <section>
    <h1>Why do I care?</h1>
    <aside class="notes">Virtual ISAs such as WebAssembly, and *gasp* JavaScript. Oh and it’s fun to make code faster!</aside>
  </section>
</section>

<section>
  <section><h1>Quick review</h1></section>
  <section>
    <p>C++11 added</p>
    <ul>
      <li class="fragment">A memory model</li>
      <li class="fragment">Threads</li>
      <li class="fragment">Classes to communicate between threads</li>
    </ul>
    <p class="fragment">Threads didn't exist before C++11</p>
  </section>
  <section>
    <h1>Sequential Consistency</h1>
    <p class="fragment">Naïve model: memory accesses are simply interleaved</p>
    <p class="fragment">Hardware doesn't work that way</p>
    <p class="fragment">Overly restrictive</p>
    <aside class="notes">Limits compiler + HW reordering / optimizations; access granularity; want to reason about atomic code regions</aside>
  </section>
  <section>
    <h1>SC-DRF</h1>
    <p class="fragment">Data race:</p>
    <ul>
      <li class="fragment">Two accesses to the same <em>memory location</em> by different threads are <em>not ordered</em></li>
      <li class="fragment">At least one of them stores to the memory location</li>
      <li class="fragment">At least one of them is not a synchronization action</li>
    </ul>
    <p class="fragment">Data races are UB</p>
    <aside class="notes">You should use address sanitizer</aside>
  </section>
  <section>
    <h1>Memory locations</h1>
    <p class="fragment">Either an object of <em>scalar type</em> or a maximal
        sequence of adjacent bit-fields all having non-zero width.</p>
    <p class="fragment">Arithmetic types, enumeration types, pointer types,
      pointer to member types, <code class="c++">std::nullptr_t</code>, and
      cv-qualified versions of these types are collectively called <em>scalar
      types</em>.
    </p>
    <aside class="notes">Also, address-freedom</aside>
  </section>
  <section>
    <h1>Ordering memory locations</h1>
    <p class="fragment">Two memory operations are ordered if they cannot occur simultaneously</p>
    <aside class="notes">That sounds simple!</aside>
  </section>
  <section>
    <h1>Ordering memory locations</h1>
    <p class="fragment">An evaluation A <em>happens before</em> an evaluation B if:
      <ul class="fragment">
        <li>A is <em>sequenced before</em> B, or</li>
        <li>A <em>inter-thread happens before</em> B</li>
      </ul>
    </p>
    <aside class="notes">More precisely...</aside>
  </section>
  <section>
    <h1>Sequenced before</h1>
    <p class="fragment">An asymmetric, transitive, pair-wise relation between
      evaluations executed by a single thread, which induces a partial order
      among those evaluations. Given any two evaluations A and B, if A
      is <em>sequenced before</em> B, then the execution of A shall precede the
      execution of B. If A is not <em>sequenced before</em> B and B is not
      <em>sequenced before</em> A, then A and B are <em>unsequenced</em>.
    </p>
  </section>
  <section>
    <h1>Inter-thread happens before</h1>
    <ul class="fragment">
      <li>A <em>synchronizes with</em> B, or</li>
      <li>A is <em>dependency-ordered before</em> B, or</li>
      <li>for some evaluation X
        <ul>
          <li>A <em>synchronizes with</em> X and X is <em>sequenced before</em> B, or</li>
          <li>A is <em>sequenced before</em> X and X <em>inter-thread happens before</em> B, or</li>
          <li>A <em>inter-thread happens before</em> X and X <em>inter-thread happens before</em> B.</li>
        </ul>
    </ul>
  </section>
  <section>
    <h1>Synchronizes with</h1>
    <p class="fragment">An atomic operation A that performs a release operation
      on an atomic object M <em>synchronizes with</em> an atomic operation B
      that performs an acquire operation on M and takes its value from any side
      effect in the release sequence headed by A.
    </p>
  </section>
  <section>
    <h1>Dependency-ordered before</h1>
    <ul class="fragment">
      <li>A performs a release operation on an atomic object M, and, in another
        thread, B performs a consume operation on M and reads a value written by
        any side effect in the release sequence headed by A, or</li>
      <li>for some evaluation X, A is <em>dependency-ordered before</em> X and X carries a dependency to B.</li>
    </ul>
    <p class="fragment">[ Note: The relation “is dependency-ordered before” is
      analogous to “synchronizes with”, but uses release/consume in place of
      release/acquire. — end note ]
    </p>
  </section>
  <section>
    <h1>Synchronization operation</h1>
    <ul>
      <li class="fragment">On one or more memory locations: consume operation,
        an acquire operation, a release operation, or both an acquire and
        release operation.</li>
      <li class="fragment">Without an associated memory location: acquire fence,
        release fence, or both an acquire and release fence.</li>
    </ul>
    <aside class="notes">Also: relaxed atomic operations are not synchronization operations; atomic read-modify-write operations have special characteristics.</aside>
  </section>
  <section>
    <h1>[intro.multithread]</h1>
    <p class="fragment">1.10 Multi-threaded executions and data races</p>
    <aside class="notes">Also defines: thread of execution, forward-progress, etc.</aside>
  </section>
  <section>
    <h1>Thread support</h1>
    <ul>
      <li class="fragment"><code class="c++">std::thread</code></li>
      <li class="fragment"><code class="c++">std::mutex</code></li>
      <li class="fragment"><code class="c++">std::shared_mutex</code></li>
      <li class="fragment"><code class="c++">std::condition_variable</code></li>
      <li class="fragment"><code class="c++">std::future</code></li>
    </ul>
    <aside class="notes">I'll ignore these for the rest of the presentation.</aside>
  </section>
  <section>
    <h1>Atomic operations</h1>
    <p class="fragment"><strong>Atomic</strong>: indivisible with respect to all other atomic accesses to that object</p>
    <aside class="notes">No tearing, no duplication, no elision.</aside>
  </section>
  <section>
    <h1>Memory order</h1>
    <ul>
      <li class="fragment"><code class="c++">relaxed</code></li>
      <li class="fragment"><code class="c++">consume</code></li>
      <li class="fragment"><code class="c++">acquire</code></li>
      <li class="fragment"><code class="c++">release</code></li>
      <li class="fragment"><code class="c++">acq_rel</code></li>
      <li class="fragment"><code class="c++">seq_cst</code></li>
    </ul>
    <aside class="notes">Used as constants passed to atomic operations. You can use a runtime variable, but your life will be sad. Actually a lattice.</aside>
  </section>
  <section>
    <h1>Atomic</h1>
    <ul>
      <li class="fragment"><code class="c++">template&lt;class T&gt; struct atomic;</code></li>
      <li class="fragment"><code class="c++">template&lt;&gt; struct atomic&lt;integral&gt;;</code></li>
      <li class="fragment"><code class="c++">template&lt;class T&gt; struct atomic&lt;T*&gt;;</code></li>
    </ul>
    <aside class="notes">All atomics operations are on atomic objects. Lifetime of memory locations, exclusively atomic or not. Holds a representation of T (alignment, etc).</aside>
  </section>
  <section>
    <h1>Atomic&lt;T&gt;</h1>
    <ul>
      <li class="fragment"><code class="c++">load</code></li>
      <li class="fragment"><code class="c++">store</code></li>
      <li class="fragment"><code class="c++">exchange</code></li>
      <li class="fragment"><code class="c++">compare_exchange_{weak,strong}</code></li>
      <li class="fragment"><code class="c++">is_lock_free</code></li>
    </ul>
    <aside class="notes">Must be trivially copyable; can be structs, but watch out for padding bits! All have atomic ordering (except lock free).</aside>
  </section>
  <section>
    <h1>Atomic&lt;integral&gt;</h1>
    <ul>
      <li class="fragment"><code class="c++">fetch_add</code></li>
      <li class="fragment"><code class="c++">fetch_sub</code></li>
      <li class="fragment"><code class="c++">fetch_and</code></li>
      <li class="fragment"><code class="c++">fetch_or</code></li>
      <li class="fragment"><code class="c++">fetch_xor</code></li>
    </ul>
    <aside class="notes">Some shorthands (without ordering) and coercions; integers are two's complement (no UB!).</aside>
  </section>
  <section>
    <h1>Atomic&lt;T*&gt;</h1>
    <ul>
      <li class="fragment"><code class="c++">fetch_add</code></li>
      <li class="fragment"><code class="c++">fetch_sub</code></li>
    </ul>
  </section>
  <section>
    <h1>Fences</h1>
    <ul>
      <li class="fragment"><code class="c++">atomic_thread_fence</code></li>
      <li class="fragment"><code class="c++">atomic_signal_fence</code></li>
    </ul>
    <aside class="notes">Only really needed with relaxed. Signal fence is basically a compiler barrier.</aside>
  </section>
  <section>
    <h1>Lock-freedom</h1>
    <p class="fragment">Guaranteed for <code class="c++">std::atomic_flag</code></p>
    <p class="fragment">Roughtly: is there a compare-exchange for this size?</p>
    <p class="fragment">This is what I'm focusing on.</p>
    <aside class="notes">Why a runtime value? If it's not lock-free, you probably want to use a coarse-grained lock (unless you're lazy and want the implementation's locks).</aside>
  </section>
</section>

<section>
  <section>
    <h1>Simple single producer / consumer</h1>
    <pre class="fragment"><code class="c++" data-noescape>
struct Data { int spam, bacon, eggs; std::atomic&lt;int&gt; ready; };
void write(Data *d) {
  d-&gt;spam = 0xBEEF;
  d-&gt;bacon = 0xCAFE;
  d-&gt;eggs = 0x0000;
  d-&gt;ready.store(1, std::memory_order_release);
}
auto read(Data *d) {
  while (!d-&gt;ready.load(std::memory_order_acquire)) ;
  return std::make_tuple(d-&gt;spam, d-&gt;bacon, d-&gt;eggs);
}
    </code></pre>
  </section>
</section>

<section>
  <section>
    <h1>We have our tools!</h1>
    <p class="fragment">Why is the language set up this way?</p>
    <p class="fragment">Provide an abstraction for relevant hardware platforms.</p>
    <aside class="notes">Let's look at a few architectures.</aside>
  </section>
  <section>
    <h1>x86-64</h1>
    <table class="fragment" style="font-size: 75%">
      <tr><td>load <code class="c++">relaxed</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>load <code class="c++">consume</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>load <code class="c++">acquire</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>load <code class="c++">seq_cst</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>store <code class="c++">relaxed</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>store <code class="c++">release</code></td><td><code class="x86asm">MOV</code></td></tr>
      <tr><td>store <code class="c++">seq_cst</code></td><td><code class="x86asm">LOCK XCHG</code></td></tr>
      <tr><td>non-<code class="c++">seq_cst</code> fence</td><td><code class="x86asm"># free!</code></td></tr>
      <tr><td><code class="c++">seq_cst</code> fence</td><td><code class="x86asm">MFENCE</code></td></tr>
    </table>
    <aside class="notes">Not mentioning RMW / cmpxchg.</aside>
  </section>
  <section>
    <h1>Power</h1>
    <table class="fragment" style="font-size: 75%">
      <tr><td>load <code class="c++">relaxed</code></td><td><code class="x86asm">ld</code></td></tr>
      <tr><td>load <code class="c++">consume</code></td><td><code class="x86asm">ld + dependencies</code></td></tr>
      <tr><td>load <code class="c++">acquire</code></td><td><code class="x86asm">ld; cmp; bc; isync</code></td></tr>
      <tr><td>load <code class="c++">seq_cst</code></td><td><code class="x86asm">hwsync; ld; cmp; bc; isync</code></td></tr>
      <tr><td>store <code class="c++">relaxed</code></td><td><code class="x86asm">st</code></td></tr>
      <tr><td>store <code class="c++">release</code></td><td><code class="x86asm">lwsync; st</code></td></tr>
      <tr><td>store <code class="c++">seq_cst</code></td><td><code class="x86asm">hwsync; st</code></td></tr>
      <tr><td><code class="c++">cmpxchg relaxed</code></td><td><code class="x86asm">_loop: lwarx; cmp; bc _exit; stwcx.; bc _loop; _exit:</code></td></tr>
      <tr><td>non-<code class="c++">seq_cst</code> fence</td><td><code class="x86asm">lwsync</code></td></tr>
      <tr><td><code class="c++">seq_cst</code> fence</td><td><code class="x86asm">hwsync</code></td></tr>
    </table>
    <aside class="notes">cmpxchg is ll / sc, more variants missing, RMW uses ll / sc. Not showing 64-bit.</aside>
  </section>
  <section>
    <h1>ARMv7</h1>
    <table class="fragment" style="font-size: 75%">
      <tr><td>load <code class="c++">relaxed</code></td><td><code class="x86asm">ldr</code></td></tr>
      <tr><td>load <code class="c++">consume</code></td><td><code class="x86asm">ldr + dependencies</code></td></tr>
      <tr><td>load <code class="c++">acquire</code></td><td><code class="x86asm">ldr; dmb</code></td></tr>
      <tr><td>load <code class="c++">seq_cst</code></td><td><code class="x86asm">lrd; dmb</code></td></tr>
      <tr><td>store <code class="c++">relaxed</code></td><td><code class="x86asm">str</code></td></tr>
      <tr><td>store <code class="c++">release</code></td><td><code class="x86asm">dmb; str</code></td></tr>
      <tr><td>store <code class="c++">seq_cst</code></td><td><code class="x86asm">dmb; str; dmb</code></td></tr>
      <tr><td><code class="c++">cmpxchg relaxed</code></td><td><code class="x86asm">_loop: ldrex; mov 0; teq; strexeq; teq 0; bne _loop</code></td></tr>
      <tr><td>fences</td><td><code class="x86asm">dmb</code></td></tr>
    </table>
    <aside class="notes">Similar to Power, same for MIPS. 64-bit is slightly horrible; has ldrexd; sometimes ldrd is single-copy atomic.</aside>
  </section>
  <section>
    <h1>ARMv8 A64</h1>
    <table class="fragment" style="font-size: 75%">
      <tr><td>load <code class="c++">relaxed</code></td><td><code class="x86asm">ldr</code></td></tr>
      <tr><td>load <code class="c++">consume</code></td><td><code class="x86asm">ldr + dependencies</code></td></tr>
      <tr><td>load <code class="c++">acquire</code></td><td><code class="x86asm">ldar</code></td></tr>
      <tr><td>load <code class="c++">seq_cst</code></td><td><code class="x86asm">ldar</code></td></tr>
      <tr><td>store <code class="c++">relaxed</code></td><td><code class="x86asm">str</code></td></tr>
      <tr><td>store <code class="c++">release</code></td><td><code class="x86asm">stlr</code></td></tr>
      <tr><td>store <code class="c++">seq_cst</code></td><td><code class="x86asm">stlr</code></td></tr>
      <tr><td><code class="c++">cmpxchg relaxed</code></td><td><code class="x86asm">_loop: ldxr; cmp; bne _exit; stxr; cbz _loop; _exit</code></td></tr>
      <tr><td>fences</td><td><code class="x86asm">dmb</code></td></tr>
    </table>
    <aside class="notes">Life imitates standards! Added "acquire" / "release" primitives, even to aarch32.</aside>
  </section>
  <section>
    <h1>Itanium</h1>
    <table class="fragment" style="font-size: 75%">
      <tr><td>load <code class="c++">relaxed</code></td><td><code class="x86asm">ld.acq</code></td></tr>
      <tr><td>load <code class="c++">consume</code></td><td><code class="x86asm">ld.acq</code></td></tr>
      <tr><td>load <code class="c++">acquire</code></td><td><code class="x86asm">ld.acq</code></td></tr>
      <tr><td>load <code class="c++">seq_cst</code></td><td><code class="x86asm">ld.acq</code></td></tr>
      <tr><td>store <code class="c++">relaxed</code></td><td><code class="x86asm">st.rel</code></td></tr>
      <tr><td>store <code class="c++">release</code></td><td><code class="x86asm">st.rel</code></td></tr>
      <tr><td>store <code class="c++">seq_cst</code></td><td><code class="x86asm">st.rel; mfB</code></td></tr>
      <tr><td><code class="c++">cmpxchg acquire</code></td><td><code class="x86asm">cmpxchg.acq</code></td></tr>
      <tr><td>non-<code class="c++">seq_cst</code> fence</td><td><code class="x86asm"># free!</code></td></tr>
      <tr><td><code class="c++">seq_cst</code> fence</td><td><code class="x86asm">mf</code></td></tr>
    </table>
  </section>
  <section>
    <h1>Alpha</h1>
    <div class="fragment" style="font-size: 50%; text-align: left">
    <p>Oh, one of my favorite (NOT!) pieces of code in the kernel is the
      implementation of the <code>smp_read_barrier_depends()</code> macro, which
      on every single architecture except for one (alpha) is a no-op.</p>
    <p>We have basically 30 or so empty definitions for it, and I think we have
      something like five uses of it. One of them, I think, is performance
      crticial, and the reason for that macro existing.</p>
    <p>What does it do? The semantics is that it's a read barrier between two
      different reads that we want to happen in order wrt two writes on the
      writing side (the writing side also has to have a <code>smp_wmb()</code>
      to order those writes). But the reason it isn't a simple read barrier is
      that the reads are actually causally *dependent*, ie we have code like</p>
    <pre class="c++"><code class="c++" data-noescape>
      first_read = read_pointer;
      smp_read_barrier_depends();
      second_read = *first_read;
    </code></pre>
    <p>and it turns out that on pretty much all architectures (except for
      alpha), the *data*dependency* will already guarantee that the CPU reads
      the thing in order. And because a read barrier can actually be quite
      expensive, we don't want to have a read barrier for this case.</p>
    <p>But alpha? Its memory consistency is so broken that even the data
      dependency doesn't actually guarantee cache access order. It's strange,
      yes. No, it's not that alpha does some magic value prediction and can do
      the second read without having even done the first read first to get the
      address. What's actually going on is that the cache itself is unordered,
      and without the read barrier, you may get a stale version from the cache
      even if the writes were forced (by the write barrier in the writer) to
      happen in the right order.</p>
    </div>
    <aside class="notes">Hard to implement C++ efficiently on Alpha! Exception that proves the rule?</aside>
  </section>
  <section>
    <h1>Takeaways</h1>
    <ul>
      <li class="fragment">C++ exposes hardware portably</li>
      <li class="fragment">Hardware changes over time</li>
      <li class="fragment">Assembly operations operation on memory locations</li>
      <li class="fragment">C++ atomics operate on datastructures</li>
    </ul>
    <aside class="notes">Portability is hard. Compiler should know best. C++ is higher level than asm. Operating on data instead of code is contended.</aside>
  </section>
</section>

<section>
  <section><h1>How do we optimize atomics?</h1></section>
  <section>
    <h2><em>as-if</em></h2>
    <p class="fragment"><strong>more atomic</strong>: don’t violate forward progress</p>
    <p class="fragment"><strong>less atomic</strong>: don’t add non-benign race which weren’t already present</p>
  </section>
  <section>
    <h2>Put another way</h2>
    <p>correct programs must work under all executions an implementation is allowed to create</p>
    <aside class="notes">
      <p>Keep in mind: compilers optimize code that compiler developers see and think are worth optimizing. We’re not trying to trip you!</p>
    </aside>
  </section>
  <section>
    <h2>What can the compiler do?</h2>
    <p class="fragment">At least as much as the hardware could do</p>
    <p class="fragment">and maybe more 😉</p>
    <aside class="notes">Is this circular, since HW adapts to the standard?</aside>
  </section>
</section>

<section>
  <section><h2>Simple example</h2>
  <pre class="fragment"><code class="c++" data-noescape>
void inc(std::atomic&lt;int&gt; *y) {
  *y += 1;
}
std::atomic&lt;int&gt; x;
void two() {
  inc(&x);
  inc(&x);
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x;
void two() {
  x += 2;
}
  </code></pre>
    <aside class="notes"><p>Adds atomicity but cannot hinder forward progress: correct.</p></aside>
  </section>
  <section><h2>Similar example</h2>
  <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x;
void inc(int val) {
  x += 1;
  x += val;
}
  </code></pre>
  <pre class="fragment"><code class="x86asm" data-noescape>
_Z3inci:
  lock incl x(%rip)
  lock addl %edi, x(%rip)
  </code></pre>
  <aside class="notes"><p>Not going to win a Turing award with this: `inc r/m` versus `add r/m, r`; both with lock prefix; inc doesn’t set carry (sometimes partial flag stall); both 3 bytes; one less register; check out Agner for μops / latency, lock prefix makes this moot. Maybe the compiler would know better after all?</p></aside>
  </section>
  <section><h2>Opportunities through inlining</h2>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool silly(std::atomic&lt;T&gt; *x, T expected, T desired) {
  x-&gt;compare_exchange_strong(expected, desired); // Inlined.
  return expected == desired;
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool silly(std::atomic&lt;T&gt; *x, T expected, T desired) {
  return x-&gt;compare_exchange_strong(expected, desired);
}
  </code></pre>
  <aside class="notes"><p>Generic code ends up with interesting cases such as these. bool is usually a flag… but returning it depends on ABI!</p></aside>
  </section>
  <section>
    <h2>A tricky one</h2>
    <p class="fragment">Works for any memory order but <code class="c++">release</code> and <code class="c++">acq_rel</code></p>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool optme(std::atomic&lt;T&gt; *x, T desired) {
  T expected = desired;
  return x-&gt;compare_exchange_strong(expected, desired
    std::memory_order_seq_cst, std::memory_order_relaxed);
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
bool optme(std::atomic&lt;T&gt; *x, T desired) {
  return x-&gt;load(std::memory_order_seq_cst) == desired; // †
}
  </code></pre>
    <p class="fragment"><small>† compiler: mark transformed load as <em>release sequence</em> <sup>‡</sup></small></p>
    <p class="fragment"><small>‡ as defined in section 1.10 of the C++ standard</small></p>
  </section>
  <section>
    <h2>Stronger, faster</h2>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
T optmetoo(std::atomic&lt;T&gt; *x, T y) {
  T z = x-&gt;load();
  x-&gt;store(y);
  return z;
}
  </code></pre>
  <pre class="fragment"><code class="c++" data-noescape>
template&lt;typename T&gt;
T optmetoo(std::atomic&lt;T&gt; *x, T y) {
  return x-&gt;exchange(y);
}
  </code></pre>
    <h2 class="fragment">better?</h2>
    <aside class="notes"><p>May not always pay off: architectures with weaker memory models may benefit from having write-after-read operations to the same location instead of having an atomic exchange.</p></aside>
  </section>
  <section>
    <h2>Moar!</h2>
    <p class="fragment">Inlining and constant propagation</p>
    <p class="fragment"><code class="c++">atomic&lt;T&gt;::fetch_and(~(T)0)</code> → <code class="c++">atomic&lt;T&gt;::load()</code></p>
    <p class="fragment">Same for <code class="c++">fetch_or(0)</code> and <code class="c++">fetch_xor(0)</code></p>
    <p class="fragment"><code class="c++">atomic&lt;T&gt;::fetch_and(0)</code> → <code class="c++">atomic&lt;T&gt;::store(0)</code></p>
  </section>
  <section>
    <h2>Takeaway</h2>
    <p class="fragment">If simple things are hard…</p>
    <p class="fragment">…is your inline assembly correct?</p>
    <p class="fragment">…will it remain correct?</p>
    <p class="fragment">Do you trust your compiler?</p>
    <aside class="notes"><p>Sorry to say, you’re already trusting your compiler (or deluding yourself).</p></aside>
  </section>
  <section>
    <p>What if the compiler emits suboptimal code?</p>
    <h2 class="fragment">File a bug!</h2>
  </section>
</section>

<section>
  <section>
    <h1>Sequence lock</h1>
    <ul>
      <li class="fragment">Get ticket number</li>
      <li class="fragment">Get the data</li>
      <li class="fragment">Check the ticket again
        <ul>
          <li>If odd: write was happening</li>
          <li>If different: write occurred</li>
          <li>If same: no write occurred, data is good</li>
        </ul>
      </li>
      <li class="fragment">If data isn’t good: try again</li>
    </ul>
    <aside class="notes"><p>Read-mostly; don’t starve writers.</p></aside>
  </section>
  <section>
    <pre><code class="c++" data-noescape>
std::tuple&lt;T, T&gt; reader() {
  T d1, d2; unsigned seq0, seq1;
  do {
    seq0 = seq.load(std::memory_order_acquire);
    d1 = data1.load(std::memory_order_relaxed);
    d2 = data2.load(std::memory_order_relaxed);
    <mark>std::atomic_thread_fence(std::memory_order_acquire);</mark>
    <mark>seq1 = seq.load(std::memory_order_relaxed);</mark>
  } while (seq0 != seq1 || seq0 &amp; 1);
  return {d1, d2};
}
    </code></pre>
    <pre><code class="c++" data-noescape>
void writer(T d1, T d2) {
  unsigned seq0 = seq.load(std::memory_order_relaxed);
  seq.store(seq0 + 1, std::memory_order_relaxed);
  data1.store(d1, std::memory_order_release);
  data2.store(d2, std::memory_order_release);
  seq.store(seq0 + 2, std::memory_order_release);
}
    </code></pre>
    <aside class="notes"><p>Relaxed can be reordered with each other; fence is heavy on some architectures; acquire over-constrains (prevents motion into critical section); not intuitive.</p></aside>
  </section>
  <section>
    <p>We <em>really</em> want a release store</p>
    <p class="fragment">(there is no release store)</p>
  </section>
  <section>
    <h2>Read-don’t-modify-write</h2>
    <pre class="fragment"><code class="c++" data-noescape>
T d1, d2;
unsigned seq0, seq1;
do {
  seq0 = seq.load(std::memory_order_acquire);
  d1 = data1.load(std::memory_order_relaxed);
  d2 = data2.load(std::memory_order_relaxed);
  <mark>seq1 = seq.fetch_add(0, std::memory_order_release);</mark>
} while (seq0 != seq1 || seq0 &amp; 1);
    </code></pre>
    <aside class="notes"><p>Better for some architectures; can move reads into critical section.</p></aside>
  </section>
  <section>
      <pre class="fragment"><code class="x86asm" data-noescape>
 mov    0x200a76(%rip),%edx        # seq
 mov    0x200a74(%rip),%eax        # data1
 mov    0x200a72(%rip),%ecx        # data2
# acquire fence
 mov    0x200a64(%rip),%esi        # seq
      </code></pre>
      <pre class="fragment"><code class="x86asm" data-noescape>
 mov    0x2004c6(%rip),%ecx        # seq
 mov    0x2004bc(%rip),%esi        # data1
 xor    %edx,%edx
 mov    0x2004af(%rip),%r8d        # data2
 lock xadd %edx,0x2004af(%rip)     # seq RdMW
      </code></pre>
      <pre class="fragment"><code class="x86asm" data-noescape>
 mov    0x200a46(%rip),%edx        # seq
 mov    0x200a44(%rip),%eax        # data1
 mov    0x200a42(%rip),%ecx        # data2
 mfence                            # optimized RdMW!
 mov    0x200a31(%rip),%esi        # seq
      </code></pre>
    <aside class="notes"><p>x86 `lock xadd` requires exclusive access! Can optimize to `mfence; mov`.</p></aside>
  </section>
  <section>
    <h2>What's better?</h2>
    <img src="seqlock.png" />
    <aside class="notes"><p>`mfence` is 3.5× slower. On POWER RdMW is faster but doesn't scale with number of threads.</p></aside>
  </section>
</section>

<section>
  <section>
    <h2>"Normal" compiler optimizations</h2>
    <p class="fragment">Dead store elimination?</p>
    <p class="fragment">Strength reduction?</p>
    <aside class="notes">Careful: avoid doing so across synchronization points (other thread of execution can observe or modify memory, which means that the traditional optimizations have to consider more intervening instructions). DSO: can't just prove atomic store post-dominates and aliases another to eliminate the other store.</aside>
  </section>
  <section>
    <h2><code class="c++">relaxed</code> optimization</h2>
    <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x, y;
void relaxed() {
  x.fetch_add(1, std::memory_order_relaxed);
  y.fetch_add(1, std::memory_order_relaxed);
  x.fetch_add(1, std::memory_order_relaxed);
  y.fetch_add(1, std::memory_order_relaxed);
}
    </code></pre>
    <pre class="fragment"><code class="c++" data-noescape>
std::atomic&lt;int&gt; x, y;
void relaxed() {
  x.fetch_add(2, std::memory_order_relaxed);
  y.fetch_add(2, std::memory_order_relaxed);
}
    </code></pre>
    <aside class="notes">Not aware of compilers which do this.</aside>
  </section>
  <section>
    <h2>Disabling reordering / fusing?</h2>
    <ul>
      <li class="fragment"><code class="c++">asm volatile("":::"memory");</code><code class="fragment c++"> // eek!</code></li>
      <li class="fragment"><code class="c++">std::atomic_signal_fence();</code><code class="fragment c++"> // wat?</code></li>
      <li class="fragment">Use <code class="c++">volatile</code>? <strong class="fragment">NO!</strong></li>
      <li class="fragment">Don't use <code class="c++">relaxed</code>?</li>
    </ul>
  </section>
  <section>
    <h2>Moar!</h2>
    <ul>
      <li class="fragment">Tag "non-atomic" functions, optimize around them</li>
      <li class="fragment">Interference-free regions</li>
      <li class="fragment">Optimize fence positioning</li>
      <li class="fragment">etc.</li>
    </ul>
    <aside class="notes">Compilers already know about "read-only" functions.</aside>
  </section>
</section>

<section>
  <h1><code class="c++">std::mutex</code> for sanity</h1>
  <ul>
    <li class="fragment">easier to use correctly</li>
    <li class="fragment">in theory...
      <ul>
        <li>it could still get optimized</li>
        <li>lock: <code class="c++">acquire</code>; unlock: <code class="c++">release</code></li>
      </ul>
    </li>
    <li class="fragment">pthread and kernel call makes this hard</li>
    <li class="fragment"><code class="c++">std::synchronic</code> to the rescue!</li>
  </ul>
</section>

<section>
  <h1>Sane Compilers Should Optimize Atomics</h1>
  <p>and you should use atomics</p>
  <p><a href="https://github.com/jfbastien/no-sane-compiler">github.com/jfbastien/no-sane-compiler</a></p>
  <p><a href="https://twitter.com/jfbastien">@jfbastien</a></p>
</section>

                        </div>
                </div>

                <script src="lib/js/head.min.js"></script>
                <script src="js/reveal.js"></script>

                <script>
                        // More info https://github.com/hakimel/reveal.js#configuration
                        Reveal.initialize({

                                controls: false, // Display controls in the bottom right corner
                                progress: true, // Display a presentation progress bar
                                history: true, // Push each slide change to the browser history
                                keyboard: true, // Enable keyboard shortcuts for navigation
                                overview: true, // Enable the slide overview mode
                                center: true, // Vertical centering of slides
                                touch: true,
                                loop: false,
                                rtl: false,
                                shuffle: false,
                                fragments: true, // Turns fragments on and off globally
                                help: true, // Flags if we should show a help overlay when the questionmark key is pressed
                                showNotes: false, // Flags if speaker notes should be visible to all viewers
                                autoSlide: 0,
                                autoSlideStoppable: true, // Stop auto-sliding after user input
                                autoSlideMethod: Reveal.navigateNext,
                                mouseWheel: false,
                                hideAddressBar: true,
                                previewLinks: false, // Opens links in an iframe preview overlay
                                transition: 'default', // none/fade/slide/convex/concave/zoom
                                transitionSpeed: 'default', // default/fast/slow
                                backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom
                                viewDistance: 3, // Number of slides away from the current that are visible
                                parallaxBackgroundImage: 'bg.jpg',
                                parallaxBackgroundSize: '2559px 1510px', // CSS syntax, e.g. "2100px 900px"
                                // Number of pixels to move the parallax background per slide
                                // - Calculated automatically unless specified
                                // - Set to 0 to disable movement along an axis
                                parallaxBackgroundHorizontal: null,
                                parallaxBackgroundVertical: null,

                                // More info https://github.com/hakimel/reveal.js#dependencies
                                dependencies: [
                                        { src: 'plugin/markdown/marked.js' },
                                        { src: 'plugin/markdown/markdown.js' },
                                        { src: 'plugin/notes/notes.js', async: true },
                                        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
                                ]
                        });
                </script>
        </body>
</html>
